<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libfbi: SetB&lt; QBoxType, QIndices &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>fbi</b>::<a class="el" href="classfbi_1_1_set_a.html">SetA</a>::<a class="el" href="structfbi_1_1_set_a_1_1_set_b.html">SetB</a>
  </div>
</div>
<div class="contents">
<h1>SetB&lt; QBoxType, QIndices &gt; Class Template Reference</h1><!-- doxytag: class="fbi::SetA::SetB" -->
<p>Subclass, when the type of the query objects differs from the type of the data objects, we need an additional layer of template specialization.  
<a href="#_details">More...</a></p>

<p><a href="classfbi_1_1_set_a_1_1_set_b-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BoxContainer , typename  = typename std::enable_if&lt;std::is_same&lt;typename BoxContainer::value_type, value_type&gt;::value&gt;::type, class QContainer , typename  = typename std::enable_if&lt;std::is_same&lt;typename QContainer::value_type, qvalue_type&gt;::value&gt;::type, typename IntervalFunctor , typename... QueryFunctors&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a80750b1987064b18fef3afe87dba440d">intersect</a> (const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QContainer &amp;qdataContainer, const QueryFunctors &amp;...qfunctors)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BoxContainer , typename  = typename std::enable_if&lt;std::is_same&lt;typename BoxContainer::value_type, value_type&gt;::value&gt;::type, class QContainer , typename  = typename std::enable_if&lt;std::is_same&lt;typename QContainer::value_type, qvalue_type&gt;::value&gt;::type, typename IntervalFunctor , typename... QueryFunctors&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a3692d75dcef386dd35d7396ce6e5e0ad">thetaIntersect</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">size_t</a> cutoff, const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QContainer &amp;qdataContainer, const QueryFunctors &amp;...qfunctors)</td></tr>
<tr><td colspan="2"><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename <br class="typebreak"/>
std::tuple_element&lt; QIndices, <br class="typebreak"/>
typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt; <a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a> &gt;<br class="typebreak"/>
::dim_type &gt;<br class="typebreak"/>
::type::second_type... &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a0d9604abeb3f086dfab8618a75f47c18">qcomp_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename <br class="typebreak"/>
std::tuple_element&lt; QIndices, <br class="typebreak"/>
typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt; <a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a> &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type... &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a802b23761194469daaa5e118a261e53c">qkey_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef QBoxType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a></td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a8e96a5b51431b0555f40a5b63e37744c">static_assert</a> (std::is_same&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qcomp_type</a> &gt;::value,&quot;CompTypes don't match&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a44cff23171ee0fa6a054e591698450e5">static_assert</a> (std::is_same&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qkey_type</a> &gt;::value,&quot;Keytypes don't match&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#ab9b948ccd8e1679191ec37112e7c665f">static_assert</a> (sizeof...(QIndices)==sizeof...(TIndices),&quot;Your number of query-dimensions doesn't match your initial indices&quot;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename BoxType, std::size_t... TIndices&gt;<br/>
template&lt;typename QBoxType, std::size_t... QIndices&gt;<br/>
 class fbi::SetA&lt; BoxType, TIndices &gt;::SetB&lt; QBoxType, QIndices &gt;</h3>

<p>Subclass, when the type of the query objects differs from the type of the data objects, we need an additional layer of template specialization. </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00648">648</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a0d9604abeb3f086dfab8618a75f47c18"></a><!-- doxytag: member="fbi::SetA::SetB::qcomp_type" ref="a0d9604abeb3f086dfab8618a75f47c18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename std::tuple_element&lt;QIndices, typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt;<a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a>&gt;::dim_type &gt;::type::second_type ... &gt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qcomp_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>As every dimension can have a different type, the appropriate comparison-operator has to be known during compile-time. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_traits.html">fbi::Traits</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00683">683</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a802b23761194469daaa5e118a261e53c"></a><!-- doxytag: member="fbi::SetA::SetB::qkey_type" ref="a802b23761194469daaa5e118a261e53c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename std::tuple_element&lt; QIndices, typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt;<a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a>&gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type ... &gt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qkey_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The key is represented by a pair of values for each dimension that should be considered for intersection tests, these pairs are wrapped in a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a> for easy access via <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#af3584954fc68a4dfbeb99ab8df9a74b1">std::get</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_traits.html">fbi::Traits</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This key_type is a subset of the original key_type, depending on the indices we're using. </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00668">668</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d320bb2d1190c25dd1064df776138fa"></a><!-- doxytag: member="fbi::SetA::SetB::qvalue_type" ref="a4d320bb2d1190c25dd1064df776138fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef QBoxType <a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a4d320bb2d1190c25dd1064df776138fa">qvalue_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A comfort typedef to refer to the type of the input boxes </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00655">655</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a80750b1987064b18fef3afe87dba440d"></a><!-- doxytag: member="fbi::SetA::SetB::intersect" ref="a80750b1987064b18fef3afe87dba440d" args="(const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QContainer &amp;qdataContainer, const QueryFunctors &amp;...qfunctors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> intersect </td>
          <td>(</td>
          <td class="paramtype">const BoxContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>dataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntervalFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>ifunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>qdataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryFunctors &amp;...&nbsp;</td>
          <td class="paramname"> <em>qfunctors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The public interface for the user to start the algorithm. </p>
<p>This function initializes the keys (consisting of intervals in several dimensions) of the intervalSet and the querySet, along with pointers to pass them to separation algorithms. <a class="el" href="classfbi_1_1_set_a_1_1_state.html#a75c86b3bc35ebb81785a4dc75a104186">State::calculate</a> has to be used to recalculate the original indices from the pointers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataContainer</em>&nbsp;</td><td>STL Container providing a forward iterator and holding a value_type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ifunctor</em>&nbsp;</td><td>This has to be either a class with a public </p>
<div class="fragment"><pre class="fragment">get&lt;Dim&gt;(const BoxType &amp; ) const; </pre></div><p> method or a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a> holding that kind of class, if multiple interval objects per box should be made. The tree will create the keys by using the functor to extract the indexed dimensions from the BoxType. They will work on every object in dataContainer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qdataContainer</em>&nbsp;</td><td>STL Container providing a forward iterator and holding a qvalue_type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qfunctors</em>&nbsp;</td><td>Like ifunctor, these functors will each create a different key, they can also be of type std::vector&lt;functor&gt;, for every object in each vector one query will be created per object in qdataContainer. (|qfunctors.<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01177.html#gafcd42f466b41bb7059f6edd3af7be4c8">size()</a>| * |qdataContainer| for every qfunctors type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>We'll return a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt;std::set&lt;IntType&gt; &gt;, as parallel edges are possible but not desired for the end result. Note that in the bipartite case, the boxes in dataContainer will be indexed from 0 upto |dataContainer|-1, whereas the ones in qdataContainer are identified by |dataContainer|..|dataContainer + qdataContainer|-1. An edge (pair of two boxes), consisting of 2 IntType values a and b, is represented by b being in the set of tails belonging to the head a (and vice versa) as there are |dataContainer + qdataContainer|-1 sets in the result. Note that every edge is inserted twice as intersection is reflective and the result an undirected graph. </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00738">738</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874">count()</a>, <a class="el" href="fbi_8h_source.html#l00489">SetA&lt; BoxType, TIndices &gt;::createPtrVector()</a>, <a class="el" href="fbi_8h_source.html#l01231">State::getLimits()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c">make_tuple()</a>, and <a class="el" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda">SetA&lt; BoxType, TIndices &gt;::static_assert()</a>.</p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l00353">SetA&lt; BoxType, TIndices &gt;::intersect()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="structfbi_1_1_set_a_1_1_set_b_a80750b1987064b18fef3afe87dba440d_cgraph.png" border="0" usemap="#structfbi_1_1_set_a_1_1_set_b_a80750b1987064b18fef3afe87dba440d_cgraph_map" alt=""></div>
<map name="structfbi_1_1_set_a_1_1_set_b_a80750b1987064b18fef3afe87dba440d_cgraph_map" id="structfbi_1_1_set_a_1_1_set_b_a80750b1987064b18fef3afe87dba440d_cgraph">
<area shape="rect" id="node3" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874" title="count" alt="" coords="212,5,271,35"/><area shape="rect" id="node5" href="classfbi_1_1_set_a.html#ad0886ceee881c83a594490832175409f" title="fbi::SetA::createPtrVector" alt="" coords="140,59,343,88"/><area shape="rect" id="node13" href="classfbi_1_1_set_a_1_1_state.html#a78b69de8dd7df106ad233aac3fea3879" title="fbi::SetA::State::getLimits" alt="" coords="140,112,343,141"/><area shape="rect" id="node15" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c" title="make_tuple" alt="" coords="192,165,291,195"/><area shape="rect" id="node17" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda" title="fbi::SetA::static_assert" alt="" coords="152,219,331,248"/><area shape="rect" id="node7" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085" title="std::vector::begin" alt="" coords="392,5,536,35"/><area shape="rect" id="node9" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066" title="std::vector::end" alt="" coords="397,59,531,88"/><area shape="rect" id="node11" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6" title="std::vector::size" alt="" coords="396,112,532,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8e96a5b51431b0555f40a5b63e37744c"></a><!-- doxytag: member="fbi::SetA::SetB::static_assert" ref="a8e96a5b51431b0555f40a5b63e37744c" args="(std::is_same&lt; comp_type, qcomp_type &gt;::value,&quot;CompTypes don't match&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_assert </td>
          <td>(</td>
          <td class="paramtype">std::is_same&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qcomp_type</a> &gt;::value&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;CompTypes don't match&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ensure that the comparison operators are equal </p>

</div>
</div>
<a class="anchor" id="a44cff23171ee0fa6a054e591698450e5"></a><!-- doxytag: member="fbi::SetA::SetB::static_assert" ref="a44cff23171ee0fa6a054e591698450e5" args="(std::is_same&lt; key_type, qkey_type &gt;::value,&quot;Keytypes don't match&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_assert </td>
          <td>(</td>
          <td class="paramtype">std::is_same&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">qkey_type</a> &gt;::value&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Keytypes don't match&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ensure that the key_types are equal </p>

</div>
</div>
<a class="anchor" id="ab9b948ccd8e1679191ec37112e7c665f"></a><!-- doxytag: member="fbi::SetA::SetB::static_assert" ref="ab9b948ccd8e1679191ec37112e7c665f" args="(sizeof...(QIndices)==sizeof...(TIndices),&quot;Your number of query&#45;dimensions doesn't match your initial indices&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_assert </td>
          <td>(</td>
          <td class="paramtype">sizeof...&nbsp;</td>
          <td class="paramname">QIndices = <code>=sizeof...(TIndices)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Your number of query-dimensions doesn't match your initial indices&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ensure that the number of querydimensions for both sets are equal </p>

</div>
</div>
<a class="anchor" id="a3692d75dcef386dd35d7396ce6e5e0ad"></a><!-- doxytag: member="fbi::SetA::SetB::thetaIntersect" ref="a3692d75dcef386dd35d7396ce6e5e0ad" args="(const size_t cutoff, const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QContainer &amp;qdataContainer, const QueryFunctors &amp;...qfunctors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> thetaIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>dataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntervalFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>ifunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>qdataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryFunctors &amp;...&nbsp;</td>
          <td class="paramname"> <em>qfunctors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The public interface for the user to start the algorithm. </p>
<p>This function initializes the keys (consisting of intervals in several dimensions) of the intervalSet and the querySet, along with pointers to pass them to separation algorithms. <a class="el" href="classfbi_1_1_set_a_1_1_state.html#a75c86b3bc35ebb81785a4dc75a104186">State::calculate</a> has to be used to recalculate the original indices from the pointers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cutoff</em>&nbsp;</td><td>The theta cutoff value for switching into OneWayScan </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataContainer</em>&nbsp;</td><td>STL Container providing a forward iterator and holding a value_type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ifunctor</em>&nbsp;</td><td>This has to be either a class with a public </p>
<div class="fragment"><pre class="fragment">get&lt;Dim&gt;(const BoxType &amp; ) const; </pre></div><p> method or a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a> holding that kind of class, if multiple interval objects per box should be made. The tree will create the keys by using the functor to extract the indexed dimensions from the BoxType. They will work on every object in dataContainer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qdataContainer</em>&nbsp;</td><td>STL Container providing a forward iterator and holding a qvalue_type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qfunctors</em>&nbsp;</td><td>Like ifunctor, these functors will each create a different key, they can also be of type std::vector&lt;functor&gt;, for every object in each vector one query will be created per object in qdataContainer. (|qfunctors.<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01177.html#gafcd42f466b41bb7059f6edd3af7be4c8">size()</a>| * |qdataContainer| for every qfunctors type) as parallel edges are possible but not desired for the end result. Note that in the bipartite case, the boxes in dataContainer will be indexed from 0 upto |dataContainer|-1, whereas the ones in qdataContainer are identified by |dataContainer|..|dataContainer + qdataContainer|-1. An edge (pair of two boxes), consisting of 2 IntType values a and b, is represented by b being in the set of tails belonging to the head a (and vice versa) as there are |dataContainer + qdataContainer|-1 sets in the result. Note that every edge is inserted twice as intersection is reflective and the result an undirected graph. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00854">854</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874">count()</a>, <a class="el" href="fbi_8h_source.html#l00489">SetA&lt; BoxType, TIndices &gt;::createPtrVector()</a>, <a class="el" href="fbi_8h_source.html#l01231">State::getLimits()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c">make_tuple()</a>, and <a class="el" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda">SetA&lt; BoxType, TIndices &gt;::static_assert()</a>.</p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l00413">SetA&lt; BoxType, TIndices &gt;::thetaIntersect()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="structfbi_1_1_set_a_1_1_set_b_a3692d75dcef386dd35d7396ce6e5e0ad_cgraph.png" border="0" usemap="#structfbi_1_1_set_a_1_1_set_b_a3692d75dcef386dd35d7396ce6e5e0ad_cgraph_map" alt=""></div>
<map name="structfbi_1_1_set_a_1_1_set_b_a3692d75dcef386dd35d7396ce6e5e0ad_cgraph_map" id="structfbi_1_1_set_a_1_1_set_b_a3692d75dcef386dd35d7396ce6e5e0ad_cgraph">
<area shape="rect" id="node3" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874" title="count" alt="" coords="252,5,311,35"/><area shape="rect" id="node5" href="classfbi_1_1_set_a.html#ad0886ceee881c83a594490832175409f" title="fbi::SetA::createPtrVector" alt="" coords="180,59,383,88"/><area shape="rect" id="node13" href="classfbi_1_1_set_a_1_1_state.html#a78b69de8dd7df106ad233aac3fea3879" title="fbi::SetA::State::getLimits" alt="" coords="180,112,383,141"/><area shape="rect" id="node15" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c" title="make_tuple" alt="" coords="232,165,331,195"/><area shape="rect" id="node17" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda" title="fbi::SetA::static_assert" alt="" coords="192,219,371,248"/><area shape="rect" id="node7" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085" title="std::vector::begin" alt="" coords="432,5,576,35"/><area shape="rect" id="node9" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066" title="std::vector::end" alt="" coords="437,59,571,88"/><area shape="rect" id="node11" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6" title="std::vector::size" alt="" coords="436,112,572,141"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="fbi_8h_source.html">fbi.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Dec 22 02:29:01 2010 for libfbi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
