<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libfbi: SetA&lt; BoxType, TIndices &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>fbi</b>::<a class="el" href="classfbi_1_1_set_a.html">SetA</a>
  </div>
</div>
<div class="contents">
<h1>SetA&lt; BoxType, TIndices &gt; Class Template Reference</h1><!-- doxytag: class="fbi::SetA" -->
<p>A class to find intersections between cartesian products of arbitrarily-typed intervals.  
<a href="#_details">More...</a></p>

<p><a href="classfbi_1_1_set_a-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_hybrid_scanner.html">HybridScanner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find intersections between boxes by recursing through virtual segment trees.  <a href="structfbi_1_1_set_a_1_1_hybrid_scanner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_hybrid_scanner_3_01_points_contain_queries_00_01_set_a_3_01_box_type_00_311f0a04bb88be7c475c1ccf7ec805d5.html">HybridScanner&lt; PointsContainQueries, SetA&lt; BoxType, TIndices...&gt;::LASTDIM &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_intersection_tester.html">IntersectionTester</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check in <img class="formulaInl" alt="$ O(Limit - Dim) $" src="form_0.png"/> if two intervals intersect by comparing in all dimensions till it's either false or all tests evaluated to true.  <a href="structfbi_1_1_set_a_1_1_intersection_tester.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_key_creator.html">KeyCreator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle the creation of keys by using given functors. As we have to handle variable indices, both from <a class="el" href="classfbi_1_1_set_a.html" title="A class to find intersections between cartesian products of arbitrarily-typed intervals...">SetA</a> and <a class="el" href="structfbi_1_1_set_a_1_1_set_b.html" title="Subclass, when the type of the query objects differs from the type of the data objects...">SetB</a>, we have to add another template class to use different <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a> parameter packs.  <a href="structfbi_1_1_set_a_1_1_key_creator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_key_printer.html">KeyPrinter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For Debug reasons, print all dimensions of a given key via cout.  <a href="structfbi_1_1_set_a_1_1_key_printer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_key_printer_3_01_n_00_01_n_01_4.html">KeyPrinter&lt; N, N &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1less_head.html">lessHead</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This Functor compares the lower endpoints of two key_type objects in a given dimension.  <a href="structfbi_1_1_set_a_1_1less_head.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1less_tail.html">lessTail</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This Functor compares the upper endpoints of two key_type objects in a given dimension.  <a href="structfbi_1_1_set_a_1_1less_tail.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_one_way_scanner.html">OneWayScanner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A scanner to find one type of intersection between two sets of intervals by looking at one of them as a set of points.  <a href="structfbi_1_1_set_a_1_1_one_way_scanner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html">SetB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclass, when the type of the query objects differs from the type of the data objects, we need an additional layer of template specialization.  <a href="structfbi_1_1_set_a_1_1_set_b.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a_1_1_state.html">State</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holding various information like the random generator state, some specific addresses of data and dimensional limits.  <a href="classfbi_1_1_set_a_1_1_state.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a7b65a16c92c856660d86d86b5ec898da">IntType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00270.html">std::set</a><br class="typebreak"/>
&lt; <a class="el" href="classfbi_1_1_set_a.html#a7b65a16c92c856660d86d86b5ec898da">IntType</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a87fb2c977d21ab6fd55fbddde2442c97">ResultType</a></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BoxContainer , typename  = typename std::enable_if&lt;            std::is_same&lt;typename BoxContainer::value_type, value_type&gt;::value&gt; ::type, typename IntervalFunctor , typename... QueryFunctors&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a76bd9bc51f6157f6a5383d08c597916e">intersect</a> (const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QueryFunctors &amp;...qfunctors)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BoxContainer , typename  = typename std::enable_if&lt;            std::is_same&lt;typename BoxContainer::value_type, value_type&gt;::value&gt; ::type, typename IntervalFunctor , typename... QueryFunctors&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a5005221a90683b2fdc5e9acd72c89826">thetaIntersect</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a> cutoff, const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QueryFunctors &amp;...qfunctors)</td></tr>
<tr><td colspan="2"><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>LASTDIM</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classfbi_1_1_set_a.html#adf764cbdea00d65edcd07bb9953ad2b7a515fb4c12e32c5640cc359a7fa02fcbc">TINDICESCORRECT</a>, 
<b>value</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename <br class="typebreak"/>
std::tuple_element&lt; TIndices, <br class="typebreak"/>
typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt; <a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a> &gt;<br class="typebreak"/>
::dim_type &gt;<br class="typebreak"/>
::type::second_type... &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a294d5d9f1d596e9376df1ae9f9d8bccf">comp_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename <br class="typebreak"/>
std::tuple_element&lt; TIndices, <br class="typebreak"/>
typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt; <a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a> &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type... &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a4dbf77ce3c81e11c566d6ab14163233b">key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classfbi_1_1_set_a.html">SetA</a>&lt; BoxType, TIndices...&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a54d449af576d6b16ec4b47b153bf54c9">SETA</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef BoxType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a></td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a094d761b708821281816f38a64553d59">SetA</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a74cea161020aff724a668837da2fbd3e">static_assert</a> (TINDICESCORRECT,&quot;Please check your <a class="el" href="classfbi_1_1_set_a.html">SetA</a>-Indices again, the \
                <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt;BoxType&gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> \
                does not have enough dimensions to use your indices&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda">static_assert</a> (sizeof...(TIndices) &gt; 0,&quot;Please specify at least one index for the dimensions&quot;)</td></tr>
<tr><td colspan="2"><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a><br class="typebreak"/>
&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#ad0886ceee881c83a594490832175409f">createPtrVector</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt; &amp;container)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <br class="typebreak"/>
std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#ab4434dca024ce6c62df965e472a20409">getApproxMedian</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;container, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a> height, <a class="el" href="classfbi_1_1_set_a_1_1_state.html">State</a> &amp;state, const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a> &gt;::type &amp;less)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <br class="typebreak"/>
std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a6497cd753dd8e86d41f894530c035746">getCompareFunctor</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#ae5eb3c869635f357939f9b0cfd3f3cb4">getHead</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#aba0ed0e173560b43bda39f9060ee7653">getHead</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a9d6307553a0d9e1210ac404e4e4bf5d2">getKey</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#aba926abdb7db7211d5354a27e05a42ff">getKey</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a9e95cb2b6d74a4e38c723d59cf570756">getTail</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::tuple_element&lt; Dim, <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a8e38852430daf63b76a08d7f089f7a28">getTail</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a951202427fb7b47bc678964077cb79f9">heuristicHeight</a> (<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a> numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Comp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a41e96c654b663d981475940e61e9a9e4">medianOfThree</a> (const T &amp;t1, const T &amp;t2, const T &amp;t3, const Comp &amp;less)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#abc41b564723c6ffafd9f729691e26c31">sortContainerHead</a> (<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;container)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfbi_1_1_set_a.html#a7c4c0c49905c68f25b604264f31ec71b">sortContainerTail</a> (<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;container)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename BoxType, std::size_t... TIndices&gt;<br/>
 class fbi::SetA&lt; BoxType, TIndices &gt;</h3>

<p>A class to find intersections between cartesian products of arbitrarily-typed intervals. </p>
<p>Based on "Fast Software for Box Intersections", by Afra Zomorodian, Herbert Edelsbrunner,</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BoxType</em>&nbsp;</td><td>The objects we're looking at, Traits&lt;BoxType&gt; has to available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>To work correctly on the given types, the templated <a class="el" href="structfbi_1_1_traits.html" title="A template for defining Traits of a specific Box class, has to define its types /...">Traits</a> class has to be specialized for the given BoxType (and QBoxType, if needed).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_traits.html" title="A template for defining Traits of a specific Box class, has to define its types /...">Traits</a> </dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TIndices</em>&nbsp;</td><td>Two boxes shall intersect if they do in these dimensions, given as a parameter pack of <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user has to specify at least one index to work on, empty TIndices won't return any results. </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00077">77</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a294d5d9f1d596e9376df1ae9f9d8bccf"></a><!-- doxytag: member="fbi::SetA::comp_type" ref="a294d5d9f1d596e9376df1ae9f9d8bccf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename std::tuple_element&lt; TIndices, typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt;<a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a>&gt;::dim_type &gt;::type::second_type ... &gt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>As every dimension can have a different type, the appropriate comparison-operator has to be known during compile-time. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_traits.html">fbi::Traits</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00143">143</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b65a16c92c856660d86d86b5ec898da"></a><!-- doxytag: member="fbi::SetA::IntType" ref="a7b65a16c92c856660d86d86b5ec898da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="classfbi_1_1_set_a.html#a7b65a16c92c856660d86d86b5ec898da">IntType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Every intersection between two elements will be represented by their corresponding index in the container holding BoxType, to save memory we decided to artificially limit the amount of elements which allows us to use 32Bit integers instead of 64Bit. </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00154">154</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4dbf77ce3c81e11c566d6ab14163233b"></a><!-- doxytag: member="fbi::SetA::key_type" ref="a4dbf77ce3c81e11c566d6ab14163233b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a>&lt; typename std::tuple_element&lt; TIndices, typename <a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt;<a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a>&gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type ... &gt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The key is represented by a pair of values for each dimension that should be considered for intersection tests, these pairs are wrapped in a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">std::tuple</a> for easy access via <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#af3584954fc68a4dfbeb99ab8df9a74b1">std::get</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_traits.html">fbi::Traits</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This key_type is a subset of the original key_type, depending on the indices we're using. </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00129">129</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87fb2c977d21ab6fd55fbddde2442c97"></a><!-- doxytag: member="fbi::SetA::ResultType" ref="a87fb2c977d21ab6fd55fbddde2442c97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00270.html">std::set</a>&lt;<a class="el" href="classfbi_1_1_set_a.html#a7b65a16c92c856660d86d86b5ec898da">IntType</a>&gt; &gt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The intersections will be returned as a adjacency list, to prevent parallel edges we're using a set for the inner dimension. </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00161">161</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54d449af576d6b16ec4b47b153bf54c9"></a><!-- doxytag: member="fbi::SetA::SETA" ref="a54d449af576d6b16ec4b47b153bf54c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classfbi_1_1_set_a.html">SetA</a>&lt;BoxType, TIndices...&gt; <a class="el" href="classfbi_1_1_set_a.html">SETA</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Small self-referencing typedef </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00087">87</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae708e458cb7cb982c2d1e40811e42f33"></a><!-- doxytag: member="fbi::SetA::value_type" ref="ae708e458cb7cb982c2d1e40811e42f33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BoxType <a class="el" href="classfbi_1_1_set_a.html#ae708e458cb7cb982c2d1e40811e42f33">value_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Short typedef to offer the STL value_type identifier for this tree. </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00093">93</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="fbi::SetA::@0" ref="a06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A compile-time constant to mark recursion tails. </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00090">90</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7"></a><!-- doxytag: member="fbi::SetA::@1" ref="adf764cbdea00d65edcd07bb9953ad2b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>enum to do compile-time indices checks and better error output </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a515fb4c12e32c5640cc359a7fa02fcbc"></a><!-- doxytag: member="TINDICESCORRECT" ref="adf764cbdea00d65edcd07bb9953ad2b7a515fb4c12e32c5640cc359a7fa02fcbc" args="" -->TINDICESCORRECT</em>&nbsp;</td><td>
<p>TINDICESCORRECT is 1 when all TIndices can be used to access a dimension the key_type, otherwise it's 0 </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00096">96</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a094d761b708821281816f38a64553d59"></a><!-- doxytag: member="fbi::SetA::SetA" ref="a094d761b708821281816f38a64553d59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfbi_1_1_set_a.html">SetA</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep ctor private to leave it as a class - we don't want a tree object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad0886ceee881c83a594490832175409f"></a><!-- doxytag: member="fbi::SetA::createPtrVector" ref="ad0886ceee881c83a594490832175409f" args="(const std::vector&lt; key_type &gt; &amp;container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt;const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *&gt; createPtrVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector with pointers to our interval data to save memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>container</em>&nbsp;</td><td>A STL container holding key_type objects, has to have a const_iterator. As our scanfunctions have to pass and copy containers of intervals, using a pointer based approach was deemed faster and safer as we won't modify the actual data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_set_a_1_1_key_creator.html#add270a7e88bae0352875bbfc1db3afef">KeyCreator::getVector()</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't move/insert into the intervalContainer afterwards, as it will invalidate all pointers. </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00489">489</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085">vector&lt; _Tp, _Alloc &gt;::begin()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066">vector&lt; _Tp, _Alloc &gt;::end()</a>, and <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6">vector&lt; _Tp, _Alloc &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l00738">SetB&lt; QBoxType, QIndices &gt;::intersect()</a>, and <a class="el" href="fbi_8h_source.html#l00854">SetB&lt; QBoxType, QIndices &gt;::thetaIntersect()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4434dca024ce6c62df965e472a20409"></a><!-- doxytag: member="fbi::SetA::getApproxMedian" ref="ab4434dca024ce6c62df965e472a20409" args="(const std::vector&lt; const key_type * &gt; &amp;container, const std::size_t height, State &amp;state, const typename std::tuple_element&lt; Dim, comp_type &gt;::type &amp;less)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const std::tuple_element&lt;Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type::first_type getApproxMedian </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a>&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfbi_1_1_set_a_1_1_state.html">State</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a> &gt;::type &amp;&nbsp;</td>
          <td class="paramname"> <em>less</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate an approximate median by using the median-of-three method on a ternary tree of given height.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Dim</em>&nbsp;</td><td>Get the median of a vector of values in the given dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classfbi_1_1_set_a.html#a951202427fb7b47bc678964077cb79f9">heuristicHeight()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>container</em>&nbsp;</td><td>The vector of values we're interested in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>The depth of the triadic tree we're resolving to get a median </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>The object holding the random number generator </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>less</em>&nbsp;</td><td>The comparison operator so that we can compare in a specific dimension </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00447">447</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="el" href="fbi_8h_source.html#l00608">SetA&lt; BoxType, TIndices &gt;::medianOfThree()</a>, <a class="el" href="fbi_8h_source.html#l01225">State::randInt()</a>, and <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6">vector&lt; _Tp, _Alloc &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a6497cd753dd8e86d41f894530c035746"></a><!-- doxytag: member="fbi::SetA::getCompareFunctor" ref="a6497cd753dd8e86d41f894530c035746" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const std::tuple_element&lt;Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">comp_type</a> &gt;::type getCompareFunctor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the comparison functor in the correct dimension </p>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00569">569</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5eb3c869635f357939f9b0cfd3f3cb4"></a><!-- doxytag: member="fbi::SetA::getHead" ref="ae5eb3c869635f357939f9b0cfd3f3cb4" args="(const key_type *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type::first_type getHead </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the lower endpoint in the correct dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00541">541</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba0ed0e173560b43bda39f9060ee7653"></a><!-- doxytag: member="fbi::SetA::getHead" ref="aba0ed0e173560b43bda39f9060ee7653" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type::first_type getHead </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the lower endpoint in the correct dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00532">532</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6307553a0d9e1210ac404e4e4bf5d2"></a><!-- doxytag: member="fbi::SetA::getKey" ref="a9d6307553a0d9e1210ac404e4e4bf5d2" args="(const key_type *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type getKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the interval in the correct dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00522">522</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba926abdb7db7211d5354a27e05a42ff"></a><!-- doxytag: member="fbi::SetA::getKey" ref="aba926abdb7db7211d5354a27e05a42ff" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type getKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some easy ways to get the correct interval / endpoints in a given dimension </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Dim</em>&nbsp;</td><td>dimension to work on. Comfort function to get the interval in the correct dimension </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00513">513</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e95cb2b6d74a4e38c723d59cf570756"></a><!-- doxytag: member="fbi::SetA::getTail" ref="a9e95cb2b6d74a4e38c723d59cf570756" args="(const key_type *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type::first_type getTail </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the upper endpoint in the correct dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00561">561</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e38852430daf63b76a08d7f089f7a28"></a><!-- doxytag: member="fbi::SetA::getTail" ref="a8e38852430daf63b76a08d7f089f7a28" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple_element&lt;Dim,<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>&gt;::type::first_type getTail </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comfort function to get the upper endpoint in the correct dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The box object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00550">550</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a951202427fb7b47bc678964077cb79f9"></a><!-- doxytag: member="fbi::SetA::heuristicHeight" ref="a951202427fb7b47bc678964077cb79f9" args="(std::size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a> heuristicHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the depth of the approximate median tree, as some constants here have to be found by experiment.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>the height of the ternary tree shall be dependent on the number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classfbi_1_1_set_a.html#ab4434dca024ce6c62df965e472a20409">getApproxMedian()</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00635">635</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01166.html#ga97020915990dc5850b6b0f4c416e576f">log()</a>.</p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l01285">HybridScanner&lt; PointsContainQueries, Dim &gt;::scan()</a>.</p>

</div>
</div>
<a class="anchor" id="a76bd9bc51f6157f6a5383d08c597916e"></a><!-- doxytag: member="fbi::SetA::intersect" ref="a76bd9bc51f6157f6a5383d08c597916e" args="(const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QueryFunctors &amp;...qfunctors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> intersect </td>
          <td>(</td>
          <td class="paramtype">const BoxContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>dataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntervalFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>ifunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryFunctors &amp;...&nbsp;</td>
          <td class="paramname"> <em>qfunctors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create two sets of keys by intersecting two sets of functors on a given dataContainer, and check if there are intersections between these keys in the dimensions the tree was initialized with. </p>
<p>In the general case, we would like to have two different types of boxes, which, given functors, produce the same key_type. As their keys are then equal and also a representation of hyperrectangles (cartesian products of intervals), it is possible to test for intersections between them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataContainer</em>&nbsp;</td><td>A container with a const_iterator, it has to hold the same type as the one the tree was instantiated with. Both key sets will be extracted by using functors on every value in this container. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ifunctor</em>&nbsp;</td><td>This has to be either a class with a public </p>
<div class="fragment"><pre class="fragment">get&lt;Dim&gt;(const BoxType &amp; ) const; </pre></div><p> method or a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a> holding that kind of class, if multiple interval objects per box should be made. The tree will create the keys by using the functor to extract the indexed dimensions from the BoxType. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qfunctors</em>&nbsp;</td><td>Like ifunctor, these functors will each create a different key, they can also be of type std::vector&lt;functor&gt;, for every object in each vector one query will be created per box in dataContainer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>We'll return a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt;std::set&lt;IntType&gt; &gt;, as parallel edges are possible but not desired for the end result. An edge (pair of two boxes), consisting of 2 IntType values a and b -which refer to the indices of these boxes in dataContainer- is represented by b being in the set of tails belonging to the head a, as there are |dataContainer| sets in the result. Note that every edge is inserted twice as intersection is reflective and the result an undirected graph.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a80750b1987064b18fef3afe87dba440d">SetB::intersect</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00353">353</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="el" href="fbi_8h_source.html#l00738">SetB&lt; QBoxType, QIndices &gt;::intersect()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="classfbi_1_1_set_a_a76bd9bc51f6157f6a5383d08c597916e_cgraph.png" border="0" usemap="#classfbi_1_1_set_a_a76bd9bc51f6157f6a5383d08c597916e_cgraph_map" alt=""></div>
<map name="classfbi_1_1_set_a_a76bd9bc51f6157f6a5383d08c597916e_cgraph_map" id="classfbi_1_1_set_a_a76bd9bc51f6157f6a5383d08c597916e_cgraph">
<area shape="rect" id="node3" href="structfbi_1_1_set_a_1_1_set_b.html#a80750b1987064b18fef3afe87dba440d" title="The public interface for the user to start the algorithm." alt="" coords="139,112,336,141"/><area shape="rect" id="node5" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874" title="count" alt="" coords="457,5,516,35"/><area shape="rect" id="node7" href="classfbi_1_1_set_a.html#ad0886ceee881c83a594490832175409f" title="createPtrVector" alt="" coords="420,59,553,88"/><area shape="rect" id="node15" href="classfbi_1_1_set_a_1_1_state.html#a78b69de8dd7df106ad233aac3fea3879" title="fbi::SetA::State::getLimits" alt="" coords="385,112,588,141"/><area shape="rect" id="node17" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c" title="make_tuple" alt="" coords="437,165,536,195"/><area shape="rect" id="node19" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda" title="static_assert" alt="" coords="431,219,543,248"/><area shape="rect" id="node9" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085" title="std::vector::begin" alt="" coords="637,5,781,35"/><area shape="rect" id="node11" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066" title="std::vector::end" alt="" coords="643,59,776,88"/><area shape="rect" id="node13" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6" title="std::vector::size" alt="" coords="641,112,777,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a41e96c654b663d981475940e61e9a9e4"></a><!-- doxytag: member="fbi::SetA::medianOfThree" ref="a41e96c654b663d981475940e61e9a9e4" args="(const T &amp;t1, const T &amp;t2, const T &amp;t3, const Comp &amp;less)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const T&amp; medianOfThree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp &amp;&nbsp;</td>
          <td class="paramname"> <em>less</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the median of three values, comparison functor has to be provided.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>type of compared values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Comp</em>&nbsp;</td><td>comparison functor </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t1</em>&nbsp;</td><td>first object to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t2</em>&nbsp;</td><td>second object to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t3</em>&nbsp;</td><td>third object to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>less</em>&nbsp;</td><td>comparison object </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classfbi_1_1_set_a.html#ab4434dca024ce6c62df965e472a20409">getApproxMedian()</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00608">608</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l00447">SetA&lt; BoxType, TIndices &gt;::getApproxMedian()</a>.</p>

</div>
</div>
<a class="anchor" id="abc41b564723c6ffafd9f729691e26c31"></a><!-- doxytag: member="fbi::SetA::sortContainerHead" ref="abc41b564723c6ffafd9f729691e26c31" args="(std::vector&lt; const key_type * &gt; &amp;container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sortContainerHead </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sort a container of pointers to key_type objects, compare their lower endpoints in the specified dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>container</em>&nbsp;</td><td>The container to sort. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00580">580</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085">vector&lt; _Tp, _Alloc &gt;::begin()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066">vector&lt; _Tp, _Alloc &gt;::end()</a>, and <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01185.html#ga2056c15a25b660ed3f0004199e11dd40">sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c4c0c49905c68f25b604264f31ec71b"></a><!-- doxytag: member="fbi::SetA::sortContainerTail" ref="a7c4c0c49905c68f25b604264f31ec71b" args="(std::vector&lt; const key_type * &gt; &amp;container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sortContainerTail </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sort a container of pointers to key_type objects, compare their upper endpoints in the specified dimension </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>container</em>&nbsp;</td><td>The container to sort </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00591">591</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085">vector&lt; _Tp, _Alloc &gt;::begin()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066">vector&lt; _Tp, _Alloc &gt;::end()</a>, and <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01185.html#ga2056c15a25b660ed3f0004199e11dd40">sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a74cea161020aff724a668837da2fbd3e"></a><!-- doxytag: member="fbi::SetA::static_assert" ref="a74cea161020aff724a668837da2fbd3e" args="(TINDICESCORRECT,&quot;Please check your SetA&#45;Indices again, the \
                Traits&lt;BoxType&gt;::key_type \
                does not have enough dimensions to use your indices&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_assert </td>
          <td>(</td>
          <td class="paramtype">TINDICESCORRECT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Please check your <a class="el" href="classfbi_1_1_set_a.html">SetA</a>&lt; BoxType, TIndices &gt;-Indices &nbsp;</td>
          <td class="paramname"> <em>again</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the\<a class="el" href="structfbi_1_1_traits.html">Traits</a>&lt; BoxType &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a>\does not have enough dimensions to use your indices&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Throw a compile error when the indices aren't correct. </p>

</div>
</div>
<a class="anchor" id="a2f48746297c1133103c4f8db5cb29dda"></a><!-- doxytag: member="fbi::SetA::static_assert" ref="a2f48746297c1133103c4f8db5cb29dda" args="(sizeof...(TIndices) &gt; 0,&quot;Please specify at least one index for the dimensions&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_assert </td>
          <td>(</td>
          <td class="paramtype">sizeof...&nbsp;</td>
          <td class="paramname">TIndices, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Please specify at least one index for the dimensions&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empty TIndices shouldn't work </p>

<p>Referenced by <a class="el" href="fbi_8h_source.html#l00949">KeyCreator&lt; KeyCreatorIndices &gt;::getVector()</a>, <a class="el" href="fbi_8h_source.html#l00738">SetB&lt; QBoxType, QIndices &gt;::intersect()</a>, and <a class="el" href="fbi_8h_source.html#l00854">SetB&lt; QBoxType, QIndices &gt;::thetaIntersect()</a>.</p>

</div>
</div>
<a class="anchor" id="a5005221a90683b2fdc5e9acd72c89826"></a><!-- doxytag: member="fbi::SetA::thetaIntersect" ref="a5005221a90683b2fdc5e9acd72c89826" args="(const std::size_t cutoff, const BoxContainer &amp;dataContainer, const IntervalFunctor &amp;ifunctor, const QueryFunctors &amp;...qfunctors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> thetaIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#ad477e282dc33a113ed64628b9b32e3dd">std::size_t</a>&nbsp;</td>
          <td class="paramname"> <em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoxContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>dataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntervalFunctor &amp;&nbsp;</td>
          <td class="paramname"> <em>ifunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryFunctors &amp;...&nbsp;</td>
          <td class="paramname"> <em>qfunctors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create two sets of keys by intersecting two sets of functors on a given dataContainer, and check if there are intersections between these keys in the dimensions the tree was initialized with. </p>
<p>In the general case, we would like to have two different types of boxes, which, given functors, produce the same key_type. As their keys are then equal and also a representation of hyperrectangles (cartesian products of intervals), it is possible to test for intersections between them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cutoff</em>&nbsp;</td><td>If one of the containers has less elements than cutoff, switch to brute-force algorithm. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataContainer</em>&nbsp;</td><td>A container with a const_iterator, it has to hold the same type as the one the tree was instantiated with. Both key sets will be extracted by using functors on every value in this container. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ifunctor</em>&nbsp;</td><td>This has to be either a class with a public </p>
<div class="fragment"><pre class="fragment">get&lt;Dim&gt;(const BoxType &amp; ) const; </pre></div><p> method or a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a> holding that kind of class, if multiple interval objects per box should be made. The tree will create the keys by using the functor to extract the indexed dimensions from the BoxType. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qfunctors</em>&nbsp;</td><td>Like ifunctor, these functors will each create a different key, they can also be of type std::vector&lt;functor&gt;, for every object in each vector one query will be created per box in dataContainer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>We'll return a <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt;std::set&lt;IntType&gt; &gt;, as parallel edges are possible but not desired for the end result. An edge (pair of two boxes), consisting of 2 IntType values a and b -which refer to the indices of these boxes in dataContainer- is represented by b being in the set of tails belonging to the head a (and vice versa), as there are |dataContainer| sets in the result. Note that every edge is inserted twice as intersection is reflective and the result an undirected graph.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structfbi_1_1_set_a_1_1_set_b.html#a80750b1987064b18fef3afe87dba440d">SetB::intersect</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l00413">413</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="el" href="fbi_8h_source.html#l00854">SetB&lt; QBoxType, QIndices &gt;::thetaIntersect()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="classfbi_1_1_set_a_a5005221a90683b2fdc5e9acd72c89826_cgraph.png" border="0" usemap="#classfbi_1_1_set_a_a5005221a90683b2fdc5e9acd72c89826_cgraph_map" alt=""></div>
<map name="classfbi_1_1_set_a_a5005221a90683b2fdc5e9acd72c89826_cgraph_map" id="classfbi_1_1_set_a_a5005221a90683b2fdc5e9acd72c89826_cgraph">
<area shape="rect" id="node3" href="structfbi_1_1_set_a_1_1_set_b.html#a3692d75dcef386dd35d7396ce6e5e0ad" title="The public interface for the user to start the algorithm." alt="" coords="179,112,416,141"/><area shape="rect" id="node5" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01184.html#ga81511cd7112567fa262b05bb22e69874" title="count" alt="" coords="537,5,596,35"/><area shape="rect" id="node7" href="classfbi_1_1_set_a.html#ad0886ceee881c83a594490832175409f" title="createPtrVector" alt="" coords="500,59,633,88"/><area shape="rect" id="node15" href="classfbi_1_1_set_a_1_1_state.html#a78b69de8dd7df106ad233aac3fea3879" title="fbi::SetA::State::getLimits" alt="" coords="465,112,668,141"/><area shape="rect" id="node17" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01138.html#aeb493b06f3d6d7fff5ed30083f9d027c" title="make_tuple" alt="" coords="517,165,616,195"/><area shape="rect" id="node19" href="classfbi_1_1_set_a.html#a2f48746297c1133103c4f8db5cb29dda" title="static_assert" alt="" coords="511,219,623,248"/><area shape="rect" id="node9" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085" title="std::vector::begin" alt="" coords="717,5,861,35"/><area shape="rect" id="node11" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066" title="std::vector::end" alt="" coords="723,59,856,88"/><area shape="rect" id="node13" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6" title="std::vector::size" alt="" coords="721,112,857,141"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="fbi_8h_source.html">fbi.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Dec 23 10:01:51 2010 for libfbi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
