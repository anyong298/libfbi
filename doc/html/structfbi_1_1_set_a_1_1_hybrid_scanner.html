<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tree: HybridScanner&lt; PointsContainQueries, Dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>fbi</b>::<a class="el" href="classfbi_1_1_set_a.html">SetA</a>::<a class="el" href="structfbi_1_1_set_a_1_1_hybrid_scanner.html">HybridScanner</a>
  </div>
</div>
<div class="contents">
<h1>HybridScanner&lt; PointsContainQueries, Dim &gt; Class Template Reference</h1><!-- doxytag: class="fbi::SetA::HybridScanner" -->
<p>Find intersections between boxes by recursing through virtual segment trees.  
<a href="#_details">More...</a></p>

<p><a href="classfbi_1_1_set_a_1_1_hybrid_scanner-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbi_1_1_set_a_1_1_hybrid_scanner.html#aa450153a66bed85f3a0fe108fd1501ba">scan</a> (<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;pointsPtrVector, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;intervalsPtrVector, const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type &amp;lowerBound, const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type &amp;upperBound, <a class="el" href="classfbi_1_1_set_a_1_1_state.html">State</a> &amp;state, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> &amp;resultVector)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename BoxType, std::size_t... TIndices&gt;<br/>
template&lt;bool PointsContainQueries, std::size_t Dim&gt;<br/>
 class fbi::SetA&lt; BoxType, TIndices &gt;::HybridScanner&lt; PointsContainQueries, Dim &gt;</h3>

<p>Find intersections between boxes by recursing through virtual segment trees. </p>
<p>We're interested in finding the intersections between two bipartite sets. Similar to other divide &amp; conquer algorithms, we will recursively divide the problem into smaller pieces, till we only have to check for intersections between two small subsets with a brute-force algorithm. To find all intersections, we have to alternate between looking at the intervals as points and as intervals, which means that every instance of <a class="el" href="structfbi_1_1_set_a_1_1_hybrid_scanner.html" title="Find intersections between boxes by recursing through virtual segment trees.">HybridScanner</a> has to spawn two HybridScanners for the next dimension with alternating inputs.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Like Quicksort, we would like to use the median to divide our sets into equal parts. As an exact median calculation would be too tiresome, we used a heuristic which is a generalized version of the standard medianOfThree method to find a good approximation. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ref <a class="el" href="classfbi_1_1_set_a.html#ab4434dca024ce6c62df965e472a20409">getApproxMedian</a> </dd>
<dd>
ref <a class="el" href="structfbi_1_1_set_a_1_1_one_way_scanner.html" title="A scanner to find one type of intersection between two sets of intervals by looking...">OneWayScanner</a> </dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l01248">1248</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa450153a66bed85f3a0fe108fd1501ba"></a><!-- doxytag: member="fbi::SetA::HybridScanner::scan" ref="aa450153a66bed85f3a0fe108fd1501ba" args="(std::vector&lt; const key_type * &gt; &amp;pointsPtrVector, std::vector&lt; const key_type * &gt; &amp;intervalsPtrVector, const typename std::tuple_element&lt; Dim, key_type &gt;::type::first_type &amp;lowerBound, const typename std::tuple_element&lt; Dim, key_type &gt;::type::first_type &amp;upperBound, State &amp;state, ResultType &amp;resultVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void scan </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pointsPtrVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">std::vector</a>&lt; const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>intervalsPtrVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>lowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::tuple_element&lt; Dim, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00709.html">key_type</a> &gt;::type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>upperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfbi_1_1_set_a_1_1_state.html">State</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html">ResultType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resultVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find intersections by solving the 1-dimensional problems of overlapping intervals. </p>
<p>This is the main recursion function, it is a divide &amp; conquer algorithm, quite similar to quicksort. By creating the nodes of a virtual segment tree in post-order, we don't have to look at the whole tree at once (saving memory). In 1 iteration, we can split the intervalset in 3 separate sets:</p>
<ul>
<li>Two of them represent the child-nodes of the virtual segment tree we're working on (we have to further seperate in the current dimension).</li>
<li>The third one is a set of solutions in the current dimension -&gt; we can solve the problem in the next dimension.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pointsPtrVector</em>&nbsp;</td><td>As we're looking at two subsets of intervals, this is the one representing the points. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>intervalsPtrVector</em>&nbsp;</td><td>These are the intervals, for this call. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lowerBound</em>&nbsp;</td><td>As a recursion invariant, all points represented by pointsPtrVector are inbetween the two bounds (check recursion), which is why all intervals spanning across these bounds are intersecting with the points (in the current dimension). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>upperBound</em>&nbsp;</td><td>see lowerBound </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>Contains a rng, can be used to track the recursion and is able to calculate the indices. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>resultVector</em>&nbsp;</td><td>We pass the resultVector around to add to it in OneWayScan </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The resultVector is only modified in <a class="el" href="structfbi_1_1_set_a_1_1_one_way_scanner.html" title="A scanner to find one type of intersection between two sets of intervals by looking...">OneWayScanner</a> so the algorithm has to end there. We're switching to the <a class="el" href="structfbi_1_1_set_a_1_1_one_way_scanner.html" title="A scanner to find one type of intersection between two sets of intervals by looking...">OneWayScanner</a>, which is more of a brute-force approach, when either of the two cutoff values is met:<ul>
<li>Only one dimension is left</li>
<li>Either set is small enough that a match in one dimension will probably lead to a match in the others. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="fbi_8h_source.html#l01285">1285</a> of file <a class="el" href="fbi_8h_source.html">fbi.h</a>.</p>

<p>References <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a52e9b3c0d3157f9db067259fc2591085">vector&lt; _Tp, _Alloc &gt;::begin()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#aaeee7e2ec5ff98c6d75b2c31059189ea">vector&lt; _Tp, _Alloc &gt;::clear()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a8c27a1d92949b353ac4503001c0d1066">vector&lt; _Tp, _Alloc &gt;::end()</a>, <a class="el" href="fbi_8h_source.html#l01240">State::getCutoff()</a>, <a class="el" href="fbi_8h_source.html#l01235">State::heuristicHeight()</a>, <a class="el" href="fbi_8h_source.html#l00635">SetA&lt; BoxType, TIndices &gt;::heuristicHeight()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a74b2762e80090843e3e6e6b609bf0ea0">vector&lt; _Tp, _Alloc &gt;::push_back()</a>, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00730.html#a49e9afae414f8d8e3a2e1221c3a050c6">vector&lt; _Tp, _Alloc &gt;::size()</a>, and <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01168.html#ga00415b0825a8d0541c5e47e8650ba8cc">swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="fbi_8h_source.html">fbi.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Dec 21 14:39:59 2010 for tree by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
